<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>虚存管理模拟程序开发文档</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-05-12 22:38:30 "/>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">虚存管理模拟程序开发文档</h1>

<p>程序开发：田勇(39051718)
</p>
<p>
组员：王博弘，梁炯潜，郭莉莎
</p>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 需求说明： </a></li>
<li><a href="#sec-2">2 主要数据结构 </a>
<ul>
<li><a href="#sec-2.1">2.1 物理页面结构page_t </a></li>
<li><a href="#sec-2.2">2.2 快表项结构tlbe_t </a></li>
<li><a href="#sec-2.3">2.3 页表项pte_t </a></li>
<li><a href="#sec-2.4">2.4 程序结构program_t </a></li>
<li><a href="#sec-2.5">2.5 页表目录pgd_t </a></li>
<li><a href="#sec-2.6">2.6 进程控制块task_t </a></li>
<li><a href="#sec-2.7">2.7 指令command_t </a></li>
<li><a href="#sec-2.8">2.8 请求request_t </a></li>
<li><a href="#sec-2.9">2.9 外存块结构fs_block_t </a></li>
<li><a href="#sec-2.10">2.10 mod_t </a></li>
<li><a href="#sec-2.11">2.11 address_t byte_t bool </a></li>
</ul>
</li>
<li><a href="#sec-3">3 主要模块 </a>
<ul>
<li><a href="#sec-3.1">3.1 虚拟机模块:vmachine.c </a>
<ul>
<li><a href="#sec-3.1.1">3.1.1 作用 </a></li>
<li><a href="#sec-3.1.2">3.1.2 主要数据 </a></li>
<li><a href="#sec-3.1.3">3.1.3 主要函数 </a></li>
</ul>
</li>
<li><a href="#sec-3.2">3.2 进程控制模块task.c </a>
<ul>
<li><a href="#sec-3.2.1">3.2.1 作用 </a></li>
<li><a href="#sec-3.2.2">3.2.2 数据 </a></li>
<li><a href="#sec-3.2.3">3.2.3 主要函数 </a></li>
</ul>
</li>
<li><a href="#sec-3.3">3.3 页帧模块memmap.c </a>
<ul>
<li><a href="#sec-3.3.1">3.3.1 作用 </a></li>
<li><a href="#sec-3.3.2">3.3.2 数据 </a></li>
<li><a href="#sec-3.3.3">3.3.3 主要函数 </a></li>
</ul>
</li>
<li><a href="#sec-3.4">3.4 快表模块tlb.c </a>
<ul>
<li><a href="#sec-3.4.1">3.4.1 作用 </a></li>
<li><a href="#sec-3.4.2">3.4.2 数据 </a></li>
<li><a href="#sec-3.4.3">3.4.3 主要函数 </a></li>
</ul>
</li>
<li><a href="#sec-3.5">3.5 设备模块 </a>
<ul>
<li><a href="#sec-3.5.1">3.5.1 作用 </a></li>
<li><a href="#sec-3.5.2">3.5.2 主要数据 </a></li>
<li><a href="#sec-3.5.3">3.5.3 主要函数 </a></li>
</ul>
</li>
<li><a href="#sec-3.6">3.6 静态程序模块 </a>
<ul>
<li><a href="#sec-3.6.1">3.6.1 作用 </a></li>
<li><a href="#sec-3.6.2">3.6.2 数据 </a></li>
</ul>
</li>
<li><a href="#sec-3.7">3.7 客户终端模块tty.c </a>
<ul>
<li><a href="#sec-3.7.1">3.7.1 作用： </a></li>
<li><a href="#sec-3.7.2">3.7.2 主要数据 </a></li>
<li><a href="#sec-3.7.3">3.7.3 主要函数 </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4">4 功能实现 </a>
<ul>
<li><a href="#sec-4.1">4.1 快表 </a></li>
<li><a href="#sec-4.2">4.2 2级页表管理 </a></li>
<li><a href="#sec-4.3">4.3 程序加载 </a></li>
<li><a href="#sec-4.4">4.4 进程控制 </a></li>
<li><a href="#sec-4.5">4.5 最近最少使用算法 </a></li>
<li><a href="#sec-4.6">4.6 内存共享 </a>
<ul>
<li><a href="#sec-4.6.1">4.6.1 fork操作 </a></li>
<li><a href="#sec-4.6.2">4.6.2 加载相同程序 </a></li>
<li><a href="#sec-4.6.3">4.6.3 共享页面的交换处理 </a></li>
</ul>
</li>
<li><a href="#sec-4.7">4.7 缺页处理 </a></li>
<li><a href="#sec-4.8">4.8 写时复制的实现 </a></li>
<li><a href="#sec-4.9">4.9 多道程序并发及客户终端与虚拟机通信的实现 </a>
<ul>
<li><a href="#sec-4.9.1">4.9.1 多道程序实现 </a></li>
<li><a href="#sec-4.9.2">4.9.2 通信 </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-5">5 运行说明 </a></li>
<li><a href="#sec-6">6 测试说明 </a></li>
<li><a href="#sec-7">7 总结与感想 </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 需求说明： </h2>
<div class="outline-text-2" id="text-1">

<p>开发一个虚拟内存模拟程序，可以很好地模拟操作系统对虚拟内存的管理。该模拟程序实现以下模拟需求：
</p><ol>
<li>
基本需求
<ol>
<li>
采用页式存储管理;
</li>
<li>
实现对缺页中断;
</li>
</ol>
</li>
<li>
高级需求
<ol>
<li>
实现多道程序虚存管理.
</li>
<li>
实现２级页表
</li>
<li>
实现快表
</li>
<li>
通过FIFO管道实现多进程间通信。
</li>
</ol>
</li>
<li>
更高级需求（创新点)
<ol>
<li>
实现内存共享
</li>
<li>
实现写时复制
</li>
<li>
模拟程序加载过程
</li>
<li>
实现最近最少使用替换算法

</li>
</ol>
</li>
</ol>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 主要数据结构 </h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1"><span class="section-number-3">2.1</span> 物理页面结构page_t </h3>
<div class="outline-text-3" id="text-2.1">




<pre class="example">typedef struct{
        int lock;// equals to refer number minus 1
        bool accessed;
        byte_t freq;
        pte_t *ref_pte;
        int block; /* block in the  */
}page_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>lock</td><td>页面锁</td><td>记录当前物理页的引用</td><td>-1:没有被引用; 0: 1个引用; &gt;0:多个引用，页面被锁住，不允许交换</td></tr>
<tr><td>accessed</td><td>访问位</td><td>在一个刷新周期内是否被访问过</td><td>刷新周期到来时，将全部表项置FALSE,每次对页面访问，都将其置为True</td></tr>
<tr><td>freq</td><td>最近使用频率</td><td>保存当页面被访问信息，用于页面替换</td><td>见<a href="#sec-2.1">最近最少使用算法</a></td></tr>
<tr><td>ref_pte</td><td>引用页表项指针</td><td>当有多个页表项引用时，只保留一个，如果没有引用，则置为NULL</td><td></td></tr>
<tr><td>block</td><td>外存块号</td><td>指向外存中数据所在的块</td><td></td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2"><span class="section-number-3">2.2</span> 快表项结构tlbe_t </h3>
<div class="outline-text-3" id="text-2.2">




<pre class="example">/* TLB enty type */
typedef struct{
        int vpage; // virtual page
        int ppage;// physic page
        bool edited;
        mod_t mode;
        bool valid;//True if it's used.
        int freq;
}tlbe_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>vpage</td><td>虚页号</td><td></td><td></td></tr>
<tr><td>ppage</td><td>物理页号</td><td></td><td></td></tr>
<tr><td>edited</td><td>修改位</td><td>指向的页面是否被修改</td><td></td></tr>
<tr><td>mode</td><td>页面标志</td><td>页面的读、写、执行权限及是否写时复制</td><td></td></tr>
<tr><td>valid</td><td>有效位</td><td>当前表项是否有效</td><td>　TRUE:表项可用，FALSE:表项无用</td></tr>
<tr><td>frep</td><td>使用频率</td><td>记录表项访问频率，用于实现快表项替换</td><td>见<a href="#sec-1">快表</a>的实现</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.3" class="outline-3">
<h3 id="sec-2.3"><span class="section-number-3">2.3</span> 页表项pte_t </h3>
<div class="outline-text-3" id="text-2.3">




<pre class="example">typedef struct {
        bool valid;//in memory?
        bool swapped;// TRUE if in swap; FALSE if in FS
        bool edited;
        
        mod_t mode;
        //      bool copy; // write on copy

        int page_ID;
}pte_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>valid</td><td>有效位</td><td>　当前页是否在内存</td><td></td></tr>
<tr><td>swapped</td><td>交换位</td><td>当前页是否已经交换</td><td></td></tr>
<tr><td>edited</td><td>修改位</td><td>页面是否已经修改</td><td></td></tr>
<tr><td>mode</td><td>页面标志</td><td>页面的读、写、执行权限及是否写时复制</td><td></td></tr>
<tr><td>page_ID</td><td>页号</td><td>物理页号或外存块号</td><td>　-1：指向全０页面; &gt;0:页号或块号</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.4" class="outline-3">
<h3 id="sec-2.4"><span class="section-number-3">2.4</span> 程序结构program_t </h3>
<div class="outline-text-3" id="text-2.4">




<pre class="example">typedef struct{
        int start_block;// the first block in the disk.
        int data; //the length of data area, whitch is readonly
        int text;//length of text area, whitch is readonly and excutable
}program_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>start_block</td><td>起始块号</td><td>程序在外存中第一块所在的块号　</td></tr>
<tr><td>data</td><td>数据段大小（页）</td><td>程序数据段所占的页数</td></tr>
<tr><td>text</td><td>程序段大小</td><td>程序程序段所占的页数</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.5" class="outline-3">
<h3 id="sec-2.5"><span class="section-number-3">2.5</span> 页表目录pgd_t </h3>
<div class="outline-text-3" id="text-2.5">




<pre class="example">typedef pte_t* pgd_t;
</pre>




</div>

</div>

<div id="outline-container-2.6" class="outline-3">
<h3 id="sec-2.6"><span class="section-number-3">2.6</span> 进程控制块task_t </h3>
<div class="outline-text-3" id="text-2.6">




<pre class="example">typedef struct _task_t{
        pid_t pid;
        pgd_t *pgd;
        program_t *program;
        struct _task_t * next;
        int fifo_fd;
}task_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>pid</td><td>进程号</td><td>客户端进程的进程号，用于区分多个进程</td></tr>
<tr><td>pgd</td><td>页目录表</td><td>指向目录数组的指针</td></tr>
<tr><td>program</td><td>程序</td><td>进程对应的程序</td></tr>
<tr><td>next</td><td>下一个进程</td><td></td></tr>
<tr><td>fifo_fd</td><td>管道描述符</td><td>该进程的输出管道</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.7" class="outline-3">
<h3 id="sec-2.7"><span class="section-number-3">2.7</span> 指令command_t </h3>
<div class="outline-text-3" id="text-2.7">




<pre class="example">typedef enum{
        NEW_TASK,
        READ,
        WRITE,
        EXEC,
        RUN,
        DISPLAY,
        QUIT,
}command_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>NEW_TASK</td><td>新进程指令</td></tr>
<tr><td>READ</td><td>读内存指令</td></tr>
<tr><td>WRITE</td><td>　写内存指令</td></tr>
<tr><td>EXEC</td><td>执行内存指令</td></tr>
<tr><td>RUN</td><td>运行程序指令</td></tr>
<tr><td>DISPLAY</td><td>显示页表信息指令</td></tr>
<tr><td>QUIT</td><td>进程退出指令</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.8" class="outline-3">
<h3 id="sec-2.8"><span class="section-number-3">2.8</span> 请求request_t </h3>
<div class="outline-text-3" id="text-2.8">




<pre class="example">typedef struct{
        pid_t pid;
        command_t command;
        address_t address;
        byte_t value;
}request_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>pid</td><td>进程id</td></tr>
<tr><td>command</td><td>请求命令</td></tr>
<tr><td>address</td><td>请求地址</td></tr>
<tr><td>value</td><td>请求值</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.9" class="outline-3">
<h3 id="sec-2.9"><span class="section-number-3">2.9</span> 外存块结构fs_block_t </h3>
<div class="outline-text-3" id="text-2.9">




<pre class="example">typedef struct _block_t{
        int page_ID;//if loaded, the phisic page
        int count; // reference count
}fs_block_t;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>page_ID</td><td>页号　</td><td>如果当前页被装入内存，其所在的页面号</td></tr>
<tr><td>count</td><td>引用数</td><td>使用当前块的进程数</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.10" class="outline-3">
<h3 id="sec-2.10"><span class="section-number-3">2.10</span> mod_t </h3>
<div class="outline-text-3" id="text-2.10">




<pre class="example">typedef unsigned char mod_t;
#define MODE_RWX 0x07
#define MODE_RW 0x06
#define MODE_W 0x02
#define MODE_R 0x04
#define MODE_X 0x01
#define MODE_C 0x08
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>MODE_RWX</td><td>可读、可写、可执行</td></tr>
<tr><td>MODE_RW</td><td>可读、可写</td></tr>
<tr><td>MODE_W</td><td>只写</td></tr>
<tr><td>MODE_R</td><td>只读</td></tr>
<tr><td>MODE_X</td><td>只执行</td></tr>
<tr><td>MODE_C</td><td>写时复制</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-2.11" class="outline-3">
<h3 id="sec-2.11"><span class="section-number-3">2.11</span> address_t byte_t bool </h3>
<div class="outline-text-3" id="text-2.11">




<pre class="example">typedef unsigned short address_t;
typedef unsigned char  byte_t;

typedef enum{
        TRUE = 1,
        FALSE = 0,
}bool;
</pre>



<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="left" /><col align="left" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>address_t</td><td>虚拟程序的地址</td><td>１６位</td><td>采用１６进制表示，如2a7b</td></tr>
<tr><td>byte_t</td><td>虚拟程序的字节</td><td>8位</td><td>１６进制，如3e</td></tr>
</tbody>
</table>


</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 主要模块 </h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1"><span class="section-number-3">3.1</span> 虚拟机模块:vmachine.c </h3>
<div class="outline-text-3" id="text-3.1">


</div>

<div id="outline-container-3.1.1" class="outline-4">
<h4 id="sec-3.1.1"><span class="section-number-4">3.1.1</span> 作用 </h4>
<div class="outline-text-4" id="text-3.1.1">

<p>虚拟机模块是整个模拟程序的核心，负责对请求的应答和从虚地址空间到物理地址之间的转换，在转化期间发生
的页表的动态生成、管理、释放，也由虚拟机模块管理。
</p></div>

</div>

<div id="outline-container-3.1.2" class="outline-4">
<h4 id="sec-3.1.2"><span class="section-number-4">3.1.2</span> 主要数据 </h4>
<div class="outline-text-4" id="text-3.1.2">

<ul>
<li id="sec-3.1.2.1">Memory <br/>
Memory本模拟程序所模拟的内存，共MEM_SIZE字节。通过对MEM_SIZE的调节，可以控制物理内存的大少。
MEM<sub>SIZE应当是PAGE</sub><sub>SIZE的整数倍。</sub>
</li>
<li id="sec-3.1.2.2">Address和AddrMode <br/>
Address模拟地址寄存器，保存对虚拟地址的进行转化后得到的实地址。

<p>
AddrMode保存对物理地址所在页的标志，包括读、写、执行权限和写时复制标志。
</p></li>
<li id="sec-3.1.2.3">Buffer <br/>
Buffer作为缓冲区，用于与客户端程序进行通信。
</li>
</ul>
</div>

</div>

<div id="outline-container-3.1.3" class="outline-4">
<h4 id="sec-3.1.3"><span class="section-number-4">3.1.3</span> 主要函数 </h4>
<div class="outline-text-4" id="text-3.1.3">

<ul>
<li id="sec-3.1.3.1">void mmap_refresh_handler(int sig) <br/>
处理时钟信息，用于实现最近最少使用原则算法。当时钟信号到来时，调用memap_refresh函数，对物理页
面更新，并重新设置时钟来激发下一次更新。
</li>
<li id="sec-3.1.3.2">void start_machine() <br/>
起动虚拟机，调用各个模块的初始化函数对各个模块进行初使化。
</li>
<li id="sec-3.1.3.3">void shutdown_machine() <br/>
关闭虚拟机，释放资源。
</li>
<li id="sec-3.1.3.4">void display(char *info), void dispaly_apgetable(task_t *task) <br/>
显示进程页表信息，并将信息通过FIFO传给客户端程序。
</li>
<li id="sec-3.1.3.5">do_response(request_t *request) <br/>
对请求进行回应。
<ol>
<li>
如果请求类型为NEW_TASK,则创建一个新的进程
</li>
<li>
如果请求的进程不是当前进程，则将进程切换到当前进程，切换过程要将快表清空。
</li>
<li>
如果请类型是WRITE,READ,EXEC则将地址转化为物理地址，转化过程中处理缺页、置换、加载等情况。
</li>
<li>
如果请求类型是RUN,则进行加载新程序替换当前程序。
</li>
<li>
如果请求类型是QUIT,则释放当前进程资源。

</li>
</ol>
</li>
<li id="sec-3.1.3.6">pte_t *lookup_pgt(address_t vaddr) <br/>
查找页表，将物理地地和物理页面的标志分别存入Address和AddrMode。在此过程中进行缺页处理、页面管理
、加载、共享等操作。

</li>
<li id="sec-3.1.3.7">bool access_addr(address_t vaddr, command_t cmd) <br/>
对READ,WRITE,EXEC进行操作，并判断是否有进行该操作的权限。该函数先查找TLB是否有要查找的页面，如
果没有，则查找页表，并将结果存入TLB中。对权限进行验证后，执行操作，并返回结果。

</li>
<li id="sec-3.1.3.8">void vm_fork(pid<sub>t</sub> child_id, task_t *ptask) <br/>
对ptask进程进行fork,产生一个进程id为child_id的子进程。子进程并不立刻分配内存空间，而是和父进
程共享内存，但此时父进程和子进程的页面全部标记为写时复制。
</li>
<li id="sec-3.1.3.9">void pgd_deep_clone(task *task) <br/>
产生一个和task共享内存的进程的内表项。
</li>
<li id="sec-3.1.3.10">exec_program(task_t *task, program_t *pro), load_program(task_t task, program_t *pro) <br/>
用一个新程序替换进程的程序，重新分配页表，将其定位到对应的外存或内存页面。
</li>
<li id="sec-3.1.3.11">lazy_load(task_t *task, int page) <br/>
对进程task的page页面进行“懶加载“：只将对应的外存块号写入页表，而外存中的页面并不加载到内存，留到
访问到该页面时再进行加载。
</li>
<li id="sec-3.1.3.12">reset<sub>pte</sub>(const pte_t *pte), free_pgd(pgd_t pgd) <br/>
释放对应的页目录和页表。
</li>
<li id="sec-3.1.3.13">main() <br/>
程序入口。

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2"><span class="section-number-3">3.2</span> 进程控制模块task.c </h3>
<div class="outline-text-3" id="text-3.2">


</div>

<div id="outline-container-3.2.1" class="outline-4">
<h4 id="sec-3.2.1"><span class="section-number-4">3.2.1</span> 作用 </h4>
<div class="outline-text-4" id="text-3.2.1">

<p>控制进行程的创建、切换、终止。
</p></div>

</div>

<div id="outline-container-3.2.2" class="outline-4">
<h4 id="sec-3.2.2"><span class="section-number-4">3.2.2</span> 数据 </h4>
<div class="outline-text-4" id="text-3.2.2">

<ul>
<li id="sec-3.2.2.1">TaskInit <br/>
模拟Linux系统中的init进程。在本模拟程序中，任何其它进行都由TaskInit进程fork出来，然后调用
EXEC命令加载其它程序。
</li>
<li id="sec-3.2.2.2">CurTask <br/>
当前进程的指针。
</li>
</ul>
</div>

</div>

<div id="outline-container-3.2.3" class="outline-4">
<h4 id="sec-3.2.3"><span class="section-number-4">3.2.3</span> 主要函数 </h4>
<div class="outline-text-4" id="text-3.2.3">

<ul>
<li id="sec-3.2.3.1">void init_task() <br/>
初始化进程模块，设定TaskInit进程，加载其程序。
</li>
<li id="sec-3.2.3.2">task_t *new_task(pid_t pid, pgd_t *pgd) <br/>
生成一人进程号为pid,页目录为pgd的新进程。
</li>
<li id="sec-3.2.3.3">bool switch_task(pid_t pid) <br/>
将当前进程切换到pid进程。
</li>
<li id="sec-3.2.3.4">task_t *free_task(task_t *task) <br/>
释放task进程的资源
</li>
<li id="sec-3.2.3.5">void kill_task(pid_t pid) <br/>
删除进程号为pid的进程。
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.3" class="outline-3">
<h3 id="sec-3.3"><span class="section-number-3">3.3</span> 页帧模块memmap.c </h3>
<div class="outline-text-3" id="text-3.3">


</div>

<div id="outline-container-3.3.1" class="outline-4">
<h4 id="sec-3.3.1"><span class="section-number-4">3.3.1</span> 作用 </h4>
<div class="outline-text-4" id="text-3.3.1">

<p>控制物理页面的加载、交换、保护、共享，维护空闲页面清单。
</p></div>

</div>

<div id="outline-container-3.3.2" class="outline-4">
<h4 id="sec-3.3.2"><span class="section-number-4">3.3.2</span> 数据 </h4>
<div class="outline-text-4" id="text-3.3.2">

<ul>
<li id="sec-3.3.2.1">MemMap[MMap<sub>SIZE]</sub> <br/>
MemMap的每一个页面对应着一个物理页面，负责维护该页面的信息。
</li>
</ul>
</div>

</div>

<div id="outline-container-3.3.3" class="outline-4">
<h4 id="sec-3.3.3"><span class="section-number-4">3.3.3</span> 主要函数 </h4>
<div class="outline-text-4" id="text-3.3.3">

<ul>
<li id="sec-3.3.3.1">void page_in(pte_t *pte) <br/>
处理缺页。先在页面中找出一个空页表（如果没有，调用page_out换出一个),然后根据pte中的信息将页面
加载入内存。
<ol>
<li>
如果swapped为True，则从交换区中将对应页面加载入内存
</li>
<li>
如果swapped为False，则从FSBlock中将页面加载到内存
</li>
<li>
如果page<sub>ID为</sub>-1，则直接使用一块空页面，并将该页面全部置零。
</li>
</ol>
</li>
<li id="sec-3.3.3.2">void page_out(int page_id) <br/>
将page_id交换出内存，如果页面没有修改过，直接丢弃该页面，并调用lazy_load设置该页的外存块号。
</li>
<li id="sec-3.3.3.3">int mempty_page() <br/>
查找所有页面，如果lock为－１,则说明此页为空，返回该页号；如果没有，则在lock为0的页面中，寻找最近
最少使用的（即freq最小的)的页面将其交换出去，并返回该页页号。
</li>
<li id="sec-3.3.3.4">void memmap_refresh() <br/>
扫描所有的页面，将页面的freq右移一位，如果页面的accessed位为TRUE，则freq最高位置１，否则置０
。

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.4" class="outline-3">
<h3 id="sec-3.4"><span class="section-number-3">3.4</span> 快表模块tlb.c </h3>
<div class="outline-text-3" id="text-3.4">


</div>

<div id="outline-container-3.4.1" class="outline-4">
<h4 id="sec-3.4.1"><span class="section-number-4">3.4.1</span> 作用 </h4>
<div class="outline-text-4" id="text-3.4.1">

<p>模拟快表.
</p></div>

</div>

<div id="outline-container-3.4.2" class="outline-4">
<h4 id="sec-3.4.2"><span class="section-number-4">3.4.2</span> 数据 </h4>
<div class="outline-text-4" id="text-3.4.2">

<ul>
<li id="sec-3.4.2.1">TLB{TLB<sub>SIZE]</sub> <br/>
快表数据.
</li>
</ul>
</div>

</div>

<div id="outline-container-3.4.3" class="outline-4">
<h4 id="sec-3.4.3"><span class="section-number-4">3.4.3</span> 主要函数 </h4>
<div class="outline-text-4" id="text-3.4.3">

<ul>
<li id="sec-3.4.3.1">void init_tlb() <br/>
初始化快表.
</li>
<li id="sec-3.4.3.2">int lookup_tlb(address_t vaddress) <br/>
在TLB中查找vaddress的页面，如果没有，则对返回-1, 否则返回对应的下标，并将Address和AddrMode
设置为物理地址和页面标志。
</li>
<li id="sec-3.4.3.3">void tlb2pgt(out), void pgt2tlb(int vpage, pte_t *pte, int in) <br/>
控制在快表和页表之间相互传递。
</li>
<li id="sec-3.4.3.4">int tlb_swap(pte_t *pte, int vpage) <br/>
在快表中交换出一个可用项，并填入pte的信息。
</li>
<li id="sec-3.4.3.5">void tlb_clear() <br/>
将所有快表项置为无效，进程切换时进行调用。

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.5" class="outline-3">
<h3 id="sec-3.5"><span class="section-number-3">3.5</span> 设备模块 </h3>
<div class="outline-text-3" id="text-3.5">


</div>

<div id="outline-container-3.5.1" class="outline-4">
<h4 id="sec-3.5.1"><span class="section-number-4">3.5.1</span> 作用 </h4>
<div class="outline-text-4" id="text-3.5.1">

<p>模拟文件系统，管理磁盘文件和交换区资源。
</p></div>

</div>

<div id="outline-container-3.5.2" class="outline-4">
<h4 id="sec-3.5.2"><span class="section-number-4">3.5.2</span> 主要数据 </h4>
<div class="outline-text-4" id="text-3.5.2">

<ul>
<li id="sec-3.5.2.1">SwapFile, FSFile <br/>
交换区文件和磁盘文件。当内存中页面使用完时，将会有页面被交换到SwapFile中，而在本模拟程序中，由于
程序指令由用户通过终端手工输入，所以FSFile并无实际作用。
</li>
<li id="sec-3.5.2.2">SwapCount[SWAP<sub>SIZE]</sub> <br/>
记录交换区中块引用次数。
</li>
<li id="sec-3.5.2.3">FSBlock[FS<sub>SIZE]</sub> <br/>
管理磁盘块的信息，具体字段含义见 <a href="#外存块结构fs\_block\_t">外存块结构fs_block_t</a>
</li>
</ul>
</div>

</div>

<div id="outline-container-3.5.3" class="outline-4">
<h4 id="sec-3.5.3"><span class="section-number-4">3.5.3</span> 主要函数 </h4>
<div class="outline-text-4" id="text-3.5.3">

<ul>
<li id="sec-3.5.3.1">int empty_swap_block() <br/>
在交换区中寻找一个空闲的块并返回其下标。
</li>
<li id="sec-3.5.3.2">void swap_in(byte_t *mem, int block) <br/>
将swap区中的一块加载到mem指向的内存。
</li>
<li id="sec-3.5.3.3">void load_block(int mem, int block) <br/>
将文件系统中的一块加载到内存。
</li>
<li id="sec-3.5.3.4">void swap_out(byte_t *mem) <br/>
将内存中的一页数据写入到交换区。

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.6" class="outline-3">
<h3 id="sec-3.6"><span class="section-number-3">3.6</span> 静态程序模块 </h3>
<div class="outline-text-3" id="text-3.6">


</div>

<div id="outline-container-3.6.1" class="outline-4">
<h4 id="sec-3.6.1"><span class="section-number-4">3.6.1</span> 作用 </h4>
<div class="outline-text-4" id="text-3.6.1">

<p>提供多个程序的段信息，以便模拟程序加载过程序，而不是随机生成每一页的控制位。
</p></div>

</div>

<div id="outline-container-3.6.2" class="outline-4">
<h4 id="sec-3.6.2"><span class="section-number-4">3.6.2</span> 数据 </h4>
<div class="outline-text-4" id="text-3.6.2">

<ul>
<li id="sec-3.6.2.1">Program[PROG_N] <br/>
程序的数组。
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3.7" class="outline-3">
<h3 id="sec-3.7"><span class="section-number-3">3.7</span> 客户终端模块tty.c </h3>
<div class="outline-text-3" id="text-3.7">


</div>

<div id="outline-container-3.7.1" class="outline-4">
<h4 id="sec-3.7.1"><span class="section-number-4">3.7.1</span> 作用： </h4>
<div class="outline-text-4" id="text-3.7.1">

<p>模拟一个进程的终端，通过终端像虚拟机发送指令。
</p></div>

</div>

<div id="outline-container-3.7.2" class="outline-4">
<h4 id="sec-3.7.2"><span class="section-number-4">3.7.2</span> 主要数据 </h4>
<div class="outline-text-4" id="text-3.7.2">

<ul>
<li id="sec-3.7.2.1">Buffer[BUFF_SIZE] <br/>
用于与虚拟机通信，接收消息及输出指令的缓冲区。
</li>
<li id="sec-3.7.2.2">Request <br/>
当前的请求。
</li>
<li id="sec-3.7.2.3">Continue <br/>
是否继续，当用户输入q指令时，Continue将被置为FALSE,程序将释放资源准备退出。
</li>
</ul>
</div>

</div>

<div id="outline-container-3.7.3" class="outline-4">
<h4 id="sec-3.7.3"><span class="section-number-4">3.7.3</span> 主要函数 </h4>
<div class="outline-text-4" id="text-3.7.3">

<ul>
<li id="sec-3.7.3.1">bool parse_command() <br/>
从终端中读一行指令，进其进行解析，将解析的结果保存在Request中。
</li>
<li id="sec-3.7.3.2">int main() <br/>
程序入口，初始化资源，并向虚拟机发出NEW_TASK指令，程序进入解析指令循环。

</li>
</ul>
</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 功能实现 </h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4.1" class="outline-3">
<h3 id="sec-4.1"><span class="section-number-3">4.1</span> 快表 </h3>
<div class="outline-text-3" id="text-4.1">

<p>通过tble_t TLB[TLB_SIZE]进行模拟快表结构。虚拟机启动时，快表进行初始化，将所有表项置为无效
。每次访问地时，先从块表中查找有效且虚页号匹配的表项，并对所有表项的freq信息进行更新。当没有找到
时，再查找页表，并且根据查找到信息对快表进行更新。
</p>
<p>
快表只对当前进程有效，所以当程序进行切换进程时，快表将进行清空操作，将所有快表项置为无效。
</p>
</div>

</div>

<div id="outline-container-4.2" class="outline-3">
<h3 id="sec-4.2"><span class="section-number-3">4.2</span> 2级页表管理 </h3>
<div class="outline-text-3" id="text-4.2">

<p>2级页表的好处是操作系统只需对需要的页表分配内存，从而可以节省大量内存。本模拟程序对此功能进行了很
好的模拟。
</p>
<p>
当新建一个进程时，页目录将会动态地被分配，然后只分配程序的data段页表和text段页表，对于堆栈断并不
分配其页表，只有当虚拟机需要访问该段时，才动态地分配该页表，并将其指内存的０块。
</p>
<p>
进程退出时，将先释放页表的指向的页面资源，再释放页表空间，最后释放目录空间。
</p></div>

</div>

<div id="outline-container-4.3" class="outline-3">
<h3 id="sec-4.3"><span class="section-number-3">4.3</span> 程序加载 </h3>
<div class="outline-text-3" id="text-4.3">

<p>本模拟程序对实际程序的结构进行了简化，我们假设：
</p><ol>
<li>
程序分为３个段：data段，只读;text；可读可执行；堆栈段，可读可写，不可执行。
</li>
<li>
程序中不包含共享库。
</li>
<li>
程序从地址０开始加载。

</li>
</ol>

<p>当程序加载时，data段和text段的页表立刻分配内存，通过lazy_load将页表指内文件系统中的块地址，
但是此时并不将其数据加载到内存，而是延迟到对该数据进行操作时再加载。对于堆栈段内的页表，如果此时
已经在页目录中分配了，则将其指向０区，即将其page_ID置为－１,否则不分配内存,留待使用时分配。
</p>
</div>

</div>

<div id="outline-container-4.4" class="outline-3">
<h3 id="sec-4.4"><span class="section-number-3">4.4</span> 进程控制 </h3>
<div class="outline-text-3" id="text-4.4">

<p>虚拟机启动时，自动生成１号进程TaskInit，以后每启动一个客户终端，都将向虚拟机发送一个NEW_TASK请
求。虚拟机接收到该请求后，通过模拟的fork操作生成一个新的Task，新的Task和TaskInit共享地址空间
，它们的页表指内相同的物理页。
</p>
<p>
当调用RUN请求时，虚拟机加载指定的新程序，替原进程的地址空间。
</p>
<p>
每次虚拟机接收到新请求时，都会检查请求是不来自当前进程，如果不是，调用switch_task进行切换，同
时清空快表。
</p>
<p>
收到退出的请求时，虚拟机会释放该进程所占有的所有资源，并将当前进程切换到TaskInit进程。
</p>
</div>

</div>

<div id="outline-container-4.5" class="outline-3">
<h3 id="sec-4.5"><span class="section-number-3">4.5</span> 最近最少使用算法 </h3>
<div class="outline-text-3" id="text-4.5">

<p>每当访问一个内存时，虚拟机都将物理页面的access位置为TRUE。同时，虚拟机维护一个时间信号，每当时钟
信号到来时，都将调用memmap_refresh，将所有的表项的freq字段右移一位，且最高位置为accessed。
这样，freq越大，表示最近使用次数越多，反之越少。当选择牺牲页时，选择一个最小的即可。
</p>
</div>

</div>

<div id="outline-container-4.6" class="outline-3">
<h3 id="sec-4.6"><span class="section-number-3">4.6</span> 内存共享 </h3>
<div class="outline-text-3" id="text-4.6">

<p>内存共享是本模拟程序提供的高级功能,通过使用共享内存，可以大幅度提高内存使用用效率。
</p>
</div>

<div id="outline-container-4.6.1" class="outline-4">
<h4 id="sec-4.6.1"><span class="section-number-4">4.6.1</span> fork操作 </h4>
<div class="outline-text-4" id="text-4.6.1">

<p>新进程建立过程中，其通过TaskInit的fork操作产生了与TaskInit指向相同页面的页目录和页表，直接共
享父进程的地址空间。
</p>
</div>

</div>

<div id="outline-container-4.6.2" class="outline-4">
<h4 id="sec-4.6.2"><span class="section-number-4">4.6.2</span> 加载相同程序 </h4>
<div class="outline-text-4" id="text-4.6.2">

<p>如果两个进程加载了相同的程序，则它们的页表在分配时会指向相同的外存块。此时调用page_in作，会查
找对应块的引用情况，如果引用数大于０，则查找其引用的页表，检查该页是否已经被修改。如果已经修改，则
重新分配一段内存页，从外存块中将数据加载到内存；否则将新进程的页表指向对应的页面，并将进程的写时复制
置１，实现共享内存。
</p>
</div>

</div>

<div id="outline-container-4.6.3" class="outline-4">
<h4 id="sec-4.6.3"><span class="section-number-4">4.6.3</span> 共享页面的交换处理 </h4>
<div class="outline-text-4" id="text-4.6.3">

<p>本程序对共享页面进行加锁，一率不允许交换。
</p>
</div>
</div>

</div>

<div id="outline-container-4.7" class="outline-3">
<h3 id="sec-4.7"><span class="section-number-3">4.7</span> 缺页处理 </h3>
<div class="outline-text-3" id="text-4.7">

<p>在任一时刻，一个进程的特定页面只可能存在４个地方：
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col align="right" /><col align="left" /><col align="left" />
</colgroup>
<tbody>
<tr><td>1</td><td>外存块</td><td>valid=FALSE, swapped=FALSE</td></tr>
<tr><td>2</td><td>内存中，即物理页面</td><td>valid=TRUE</td></tr>
<tr><td>3</td><td>交换区中</td><td>valid=TRUE, swapped=TRUE</td></tr>
<tr><td>4</td><td>0区(一个虚拟的页面，其数据全部为０)</td><td>valid=FALSE, page_ID=-1</td></tr>
</tbody>
</table>


<p>
在进行缺页处理时，虚拟机会判断该页面是否可以共享页面，如果不可以，则选择一个没有使用的页面。如果
所有页面都已经使用，根据最近最少使用原则，选择一个页将其交换出内存，然后根据页面所在的位置，调用相
应的函数将数据加载到选择的空闲页面中。  
</p>
</div>

</div>

<div id="outline-container-4.8" class="outline-3">
<h3 id="sec-4.8"><span class="section-number-3">4.8</span> 写时复制的实现 </h3>
<div class="outline-text-3" id="text-4.8">

<p>在每个页表项中，都有写时复制位，如果为１则表示该页处于写时复制状态。当一个进程的某个页面要和其它进
程共享页面时，所有共享该页面的进程对应的页表项都要将写时复制位置１。
</p>
<p>
进行写操作时，必须先检查该页的写时复制位，如果为０，表示没有页面共享，继续执行操作即可。如果为１，
表示*可能*还有其它进程在使用该页，进一步检查物理页面的lock字段，如果lock大于０，则该页面正被多个
进程引用，必须先将该页面复制到一个新的页面，将*当前进程*的写时复制位置０，然后才可以进行写操作；如
果lock位&lt;1,则共享页面已经复制，只要将当前进行的该页表项写时复制位置０，就可以进写操作。
</p>
</div>

</div>

<div id="outline-container-4.9" class="outline-3">
<h3 id="sec-4.9"><span class="section-number-3">4.9</span> 多道程序并发及客户终端与虚拟机通信的实现 </h3>
<div class="outline-text-3" id="text-4.9">


</div>

<div id="outline-container-4.9.1" class="outline-4">
<h4 id="sec-4.9.1"><span class="section-number-4">4.9.1</span> 多道程序实现 </h4>
<div class="outline-text-4" id="text-4.9.1">

<p>虚拟机程序通过一个进程模拟，多道程序通过多个客户终端进程模拟。用户通过客户终端向虚拟机发送指令请求
。请求中包含有该进程的进程号，虚拟机程序借此对客户终端进行判别和进行进程切换操作。
</p></div>

</div>

<div id="outline-container-4.9.2" class="outline-4">
<h4 id="sec-4.9.2"><span class="section-number-4">4.9.2</span> 通信 </h4>
<div class="outline-text-4" id="text-4.9.2">

<p>虚拟机进程创建一个服务管道，客户终端向其中写请求，虚拟机从中读取请求并处理请求。每个客户终端有一个
命名管道，虚拟机进程处理完请求后，将应答写入对应客户进程的命名管道，客户终端读取该管道并显示。
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 运行说明 </h2>
<div class="outline-text-2" id="text-5">

<p>本程序的开发环境为Ubuntu11.10操作系统，采用c语言开发，使用gcc 4.6.1编译。
程序分为２个部分，分别为vmachine和tty。tty可以有多个实例用以模拟多个进程，在运行tty之前，必须
先运行vmachine。
</p>
<p>
本程序的操作命令均从tty输入，tty将请求传给vmachine进行处理，vmachine会输出详细的处理过程，并
结果发回到tty显示.
</p>
<p>
命令:
</p>


<pre class="example">Q:         退出程序。
R xxxx:    从地址xxxx读一字节。
W xxxx xx: 将值xx写入地址xxxx.
X xxxx:    执行地址xxxx的指令（实际上只做可执行权限的检查).
E n:       加载程序n,替换当前程序。
D:         显示当前进程的页表。
S:         关闭模拟程序。
</pre>




</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 测试说明 </h2>
<div class="outline-text-2" id="text-6">

<p>本程序在Ubuntu11.10环境下测试。bash 版本为4.2.10.
在debug目录下可以运行debug.sh脚本自动测试，该脚本会按照debug.dat和debug2.dat中的指令向tty
输入测试指令。
用户也可以手工测试，方法为:
</p><ol>
<li>
运行vmachine
</li>
<li>
运行一个或多个tty程序
</li>
<li>
在tty中输入特定指令，观察程序输出。
</li>
</ol>

<p>在debug目录下的img目录中，给出了一些测试用例截图，可供参考。
</p>

</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 总结与感想 </h2>
<div class="outline-text-2" id="text-7">

<p>本程序是北京航空航天大学计算机学院操作系统第３次课程设计。从编写第一行伪代码，到撰写本文档，历时２
个月。代码由田勇(39051718)完成，王博弘、梁炯潜、郭莉莎参与了讨论设计，并给出了一些很好的建议。
</p>
<p>
在设计本程序时，最初参考了实验教程上给出的程序，但很快发现该程序不能很好模拟操作系统对虚拟内存的管
理。于是决定另起炉灶，从新设计一个更加接近真实系统的模拟程序。
</p>
<p>
最初的设计是用２个文件分别模拟磁盘文件和交换区。程序中有一解释程序，可以执行事先写入磁盘文件中的由
一系列指令构成的虚拟程序。客户终端只用来控制执行哪一个程序。这样，实际上是要实现一个虚拟机。但后来
发现其工作量超出预计数倍，不得不忍痛删除大量代码，只保留与虚存管理相关的部分。从主程序名vmachine
、进程控制块task_t、设备控制模块等处，仍可以看出当初设计的痕迹。
</p>
<p>
精简后的设计并没有简化对虚存管理的模拟。除了实现一些基础的功能以外，本程序还实现了共享内存、写时复
制等高级功能，不仅如此，对于进程的生存周期，本程序也进行了很好模拟。但同时，复杂的功能也带来了复杂
的代码和调试的困难。在本文档中，各个功能是分开描述的，但在代码中却难以分开实现。大多数情况下，多个
功能都杂糅在一起，使得对数据的操作过程十分繁琐复杂，牵一发而动全身。这样，不仅查找错误十分困难，修
改起来也不简单，往往改动一处，又导致另一处错误。因此，在提交本次作业时，可能仍然存在未发现的错误。
</p>
<p>
通过本次作业及小组讨论，本组成员对操作系统虚存管理有了更加深刻的理解，同时也掌握了程序运行的机理，
并且对Linux编程环境更加熟悉，很好的达到了本次大作业的目的。
</p>

</div>
</div>
<div id="postamble">
<p class="author"> Author: 
<a href="mailto:Gnoy@GNOY-PC">&lt;Gnoy@GNOY-PC&gt;</a>
</p>
<p class="date"> Date: 2012-05-12 22:38:30 </p>
<p class="creator">HTML generated by org-mode 6.33x in emacs 23</p>
</div>
</div>
</body>
</html>
